<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KanBanProj</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: "Inter", "Segoe UI", Arial, sans-serif;
            background: #f4f5f7;
            margin: 0;
            padding: 20px;
        }

        .container {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
            overflow-x: auto;
            overflow-y: hidden;
            height: calc(100vh - 40px);
            padding-bottom: 20px;
        }

        .task-column {
            background: #ebecf0;
            border-radius: 8px;
            padding: 12px;
            width: 280px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            max-height: 100%;
            cursor: grab;
        }
        
        .task-column.dragging-column {
            opacity: 0.5;
            transform: rotate(1deg);
        }

        .column-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-left: 4px;
        }

        .column-header h2 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0;
            color: #172b4d;
            cursor: pointer;
        }

        .column-header h2:hover {
            background-color: rgba(9, 30, 66, 0.08);
            border-radius: 4px;
        }

        .tasks {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
            list-style: none;
            padding: 0;
            margin: 0 0 10px;
            overflow-y: auto;
            min-height: 20px; 
        }

        .task {
            background: white;
            border-radius: 6px;
            padding: 10px 12px;
            box-shadow: 0 1px 2px rgba(9,30,66,0.15);
            cursor: grab;
            border: none;
            transition: background 0.15s ease;
            position: relative;
            padding-right: 70px; /* Espace augmenté pour les 3 boutons */
        }

        .task:hover {
            filter: brightness(0.98); /* Légère assombrissement au survol au lieu de changer la couleur fixe */
        }

        .task:active {
            cursor: grabbing;
        }

        /* Styles des boutons d'action */
        .action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 2px 4px;
            border-radius: 4px;
            transition: background 0.15s, color 0.15s;
            line-height: 1;
            position: absolute;
            top: 8px;
            opacity: 0; /* Caché par défaut */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .task:hover .action-btn {
            opacity: 1;
        }

        .delete-btn {
            right: 4px;
            color: #6b778c;
        }
        .delete-btn:hover {
            background: rgba(191, 38, 0, 0.15);
            color: #bf2600;
        }

        .edit-btn {
            right: 26px;
            color: #6b778c;
        }
        .edit-btn:hover {
            background: rgba(9, 30, 66, 0.08);
            color: #172b4d;
        }

        /* Sélecteur de couleur */
        .color-picker-container {
            position: absolute;
            right: 48px;
            top: 8px;
            width: 20px;
            height: 20px;
            opacity: 0;
            transition: opacity 0.15s;
            overflow: hidden; /* Pour masquer l'input natif qui dépasse */
        }
        
        .task:hover .color-picker-container {
            opacity: 1;
        }

        @media screen and (max-width: 600px) {
        .column {
            width: 100%;
            display: block;
            margin-bottom: 20px;
        }
        }

        .card {
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
            padding: 16px;
            text-align: center;
            background-color: #f1f1f1;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Le contenu du tableau sera généré ici par JS -->
    </div>

    <script>
        // --- Données initiales par défaut ---
        const defaultData = {
            "cards": {
                "0": { "task": "lire le cours d'HTML", "due": "2025-11-20", "color": "#ffffff" },
                "1": { "task": "faire les exercices CSS", "due": "2025-11-22", "color": "#ffffff" },
                "2": { "task": "réviser JavaScript (DOM)", "due": "2025-11-25", "color": "#ffffff" },
                "3": { "task": "créer un mini-projet HTML/CSS", "due": "2025-11-28", "color": "#e6fffa" }
            },
            "table": {
                "0": { "name": "TO-DO", "cards": ["0", "1"] },
                "1": { "name": "IN-PROGRESS", "cards": ["2"] },
                "2": { "name": "DONE", "cards": ["3"] }
            },
            "columnOrder": ["0", "1", "2"]
        };

        // --- Chargement des données ---
        // On essaie de récupérer les données du LocalStorage, sinon on utilise les défauts
        let boardData = JSON.parse(localStorage.getItem('kanbanBoardData')) || defaultData;

        // Migration : s'assurer que columnOrder existe (pour les anciennes sauvegardes)
        if (!boardData.columnOrder) {
            boardData.columnOrder = Object.keys(boardData.table);
        }

        // --- Fonction de sauvegarde ---
        function saveBoard() {
            localStorage.setItem('kanbanBoardData', JSON.stringify(boardData));
        }

        // --- Validation de la date ---
        function isValidDate(dateString) {
            const regex = /^\d{4}-\d{2}-\d{2}$/;
            if (!regex.test(dateString)) return false;
            const date = new Date(dateString);
            // Vérifie si c'est une date valide et si la chaîne correspond à la partie date ISO
            return date instanceof Date && !isNaN(date) && date.toISOString().slice(0,10) === dateString;
        }

        // --- Actions (Suppression, Édition) ---

        // Supprimer une colonne (liste)
        function deleteColumn(colId) {
            if (confirm("Êtes-vous sûr de vouloir supprimer cette liste et toutes ses tâches ?")) {
                // Nettoyage des cartes orphelines
                boardData.table[colId].cards.forEach(cardId => {
                    delete boardData.cards[cardId];
                });
                // Suppression de la colonne
                delete boardData.table[colId];
                // Mise à jour de l'ordre
                boardData.columnOrder = boardData.columnOrder.filter(id => id !== colId);
                
                saveBoard();
                renderBoard(boardData);
            }
        }

        // Supprimer une tâche
        function deleteTask(colId, taskId) {
            if (confirm("Supprimer cette tâche ?")) {
                boardData.table[colId].cards = boardData.table[colId].cards.filter(id => id !== taskId);
                delete boardData.cards[taskId];
                saveBoard();
                renderBoard(boardData);
            }
        }

        // Éditer le nom d'une colonne
        function editColumn(colId) {
            const currentName = boardData.table[colId].name;
            const newName = prompt("Entrez le nouveau titre de la liste :", currentName);
            if (newName && newName.trim() !== "") {
                boardData.table[colId].name = newName;
                saveBoard();
                renderBoard(boardData);
            }
        }

        // Éditer une tâche (Nom et Date)
        function editTask(cardId) {
            const card = boardData.cards[cardId];
            const newTask = prompt("Modifier la description :", card.task);
            if (newTask === null) return; // Annulé
            
            const newDue = prompt("Modifier la date d'échéance (AAAA-MM-JJ) :", card.due);
            if (newDue === null) return; // Annulé

            // Validation de la date
            if (newDue !== "" && !isValidDate(newDue)) {
                alert("Format de date invalide. Veuillez utiliser AAAA-MM-JJ.");
                return;
            }

            if (newTask || newDue) {
                boardData.cards[cardId] = {
                    ...card,
                    task: newTask || card.task,
                    due: newDue || card.due
                };
                saveBoard();
                renderBoard(boardData);
            }
        }

        // Changer la couleur d'une tâche
        function changeTaskColor(cardId, newColor) {
            if (boardData.cards[cardId]) {
                boardData.cards[cardId].color = newColor;
                saveBoard();
                // Pas besoin de tout re-rendre, on peut juste appliquer le style si on veut optimiser,
                // mais renderBoard est plus sûr pour la cohérence.
                renderBoard(boardData);
            }
        }

        // --- Fonction de Rendu Principal ---

        function renderBoard(data) {
            const container = document.querySelector(".container");
            container.innerHTML = "";

            // Boucle sur les colonnes selon l'ordre défini
            data.columnOrder.forEach((colId) => {
                const colData = data.table[colId];
                if (!colData) return;

                const column = document.createElement("div");
                column.className = "task-column";
                column.draggable = true; // Rend la colonne déplaçable
                column.dataset.id = colId;

                // En-tête de colonne
                const headerDiv = document.createElement("div");
                headerDiv.className = "column-header";

                const h2 = document.createElement("h2");
                h2.textContent = colData.name;
                h2.title = "Cliquez pour renommer la liste";
                h2.onclick = () => editColumn(colId);
                
                const deleteColBtn = document.createElement("button");
                deleteColBtn.className = "col-delete-btn";
                deleteColBtn.innerHTML = "&times;";
                deleteColBtn.title = "Supprimer la liste";
                deleteColBtn.onclick = () => deleteColumn(colId);

                headerDiv.appendChild(h2);
                headerDiv.appendChild(deleteColBtn);
                column.appendChild(headerDiv);

                // Liste des tâches (ul)
                const ul = document.createElement("ul");
                ul.className = "tasks";

                colData.cards.forEach((cardId) => {
                    const card = data.cards[cardId];
                    if (card) {
                        const li = document.createElement("li");
                        li.className = "task";
                        li.draggable = true; // Rend la tâche déplaçable
                        li.dataset.id = cardId;
                        
                        // Appliquer la couleur de fond sauvegardée
                        li.style.backgroundColor = card.color || '#ffffff';

                        li.innerHTML = `
                            <strong>${card.task}</strong>
                            <br>
                            <small style="color: #555;">Échéance : ${card.due}</small>
                        `;
                        
                        // --- Boutons d'action sur la tâche ---

                        // 1. Sélecteur de couleur
                        const colorContainer = document.createElement("div");
                        colorContainer.className = "color-picker-container";
                        colorContainer.title = "Changer la couleur";
                        
                        const colorInput = document.createElement("input");
                        colorInput.type = "color";
                        colorInput.className = "color-input";
                        colorInput.value = card.color || "#ffffff";
                        colorInput.onchange = (e) => changeTaskColor(cardId, e.target.value);
                        // Empêcher le drag and drop quand on clique sur le color picker
                        colorInput.onclick = (e) => e.stopPropagation();
                        
                        colorContainer.appendChild(colorInput);

                        // 2. Bouton Éditer (Crayon)
                        const editTaskBtn = document.createElement("button");
                        editTaskBtn.className = "action-btn edit-btn";
                        editTaskBtn.innerHTML = "&#9998;";
                        editTaskBtn.title = "Éditer la tâche";
                        editTaskBtn.onclick = (e) => {
                            e.stopPropagation();
                            editTask(cardId);
                        };

                        // 3. Bouton Supprimer (X)
                        const deleteTaskBtn = document.createElement("button");
                        deleteTaskBtn.className = "action-btn delete-btn";
                        deleteTaskBtn.innerHTML = "&times;";
                        deleteTaskBtn.title = "Supprimer la tâche";
                        deleteTaskBtn.onclick = (e) => {
                            e.stopPropagation();
                            deleteTask(colId, cardId);
                        };

                        li.appendChild(colorContainer);
                        li.appendChild(editTaskBtn);
                        li.appendChild(deleteTaskBtn);
                        ul.appendChild(li);
                    }
                });

                column.appendChild(ul);

                // Bouton "Ajouter une carte"
                const addCardBtn = document.createElement("button");
                addCardBtn.className = "add-card-btn";
                addCardBtn.innerHTML = "<span>+</span> Ajouter une carte";
                addCardBtn.onclick = () => {
                    const taskText = prompt("Entrez la description de la tâche :");
                    if (taskText) {
                        const today = new Date().toISOString().split('T')[0];
                        const dateText = prompt("Entrez la date d'échéance (AAAA-MM-JJ) :", today);
                        
                        if (dateText === null) return; // Annulé
                        
                        // Validation
                        if (!isValidDate(dateText)) {
                            alert("Format de date invalide. Utilisez AAAA-MM-JJ.");
                            return;
                        }

                        const newCardId = "card-" + Date.now();
                        
                        // Création de la nouvelle carte avec couleur par défaut
                        boardData.cards[newCardId] = { 
                            task: taskText, 
                            due: dateText,
                            color: "#ffffff"
                        };
                        boardData.table[colId].cards.push(newCardId);
                        
                        saveBoard();
                        renderBoard(boardData);
                    }
                };
                column.appendChild(addCardBtn);

                container.appendChild(column);
            });

            // Bouton "Ajouter une autre liste"
            const addColumnBtn = document.createElement("button");
            addColumnBtn.className = "add-column-btn";
            addColumnBtn.textContent = "+ Ajouter une autre liste";
            addColumnBtn.onclick = () => {
                const listName = prompt("Entrez le titre de la liste :");
                if (listName) {
                    const newColId = "col-" + Date.now();
                    boardData.table[newColId] = { 
                        name: listName, 
                        cards: [] 
                    };
                    boardData.columnOrder.push(newColId);
                    saveBoard();
                    renderBoard(boardData);
                }
            };
            container.appendChild(addColumnBtn);

            // Ré-initialiser les écouteurs d'événements Drag & Drop
            initTaskDragAndDrop();
            initColumnDragAndDrop();
        }

        // --- Fonctions Drag & Drop (Logique de glisser-déposer) ---

        // Met à jour l'objet boardData en lisant le DOM actuel
        function updateBoardDataFromDOM() {
            const container = document.querySelector(".container");
            const columns = container.querySelectorAll(".task-column");
            const newColumnOrder = [];
            
            columns.forEach(col => {
                const colId = col.dataset.id;
                newColumnOrder.push(colId);
                const tasksUl = col.querySelector(".tasks");
                const newCardOrder = [];
                tasksUl.querySelectorAll(".task").forEach(task => {
                    if (task.dataset.id) newCardOrder.push(task.dataset.id);
                });
                if (boardData.table[colId]) boardData.table[colId].cards = newCardOrder;
            });

            boardData.columnOrder = newColumnOrder;
            saveBoard();
        }

        // Crée l'élément fantôme gris (placeholder)
        function makePlaceholder(draggedTask) {
            const placeholder = document.createElement("li");
            placeholder.classList.add("placeholder");
            placeholder.style.height = `${draggedTask.offsetHeight}px`;
            return placeholder;
        }

        // Gère le déplacement du placeholder pour les tâches
        function moveTaskPlaceholder(event) {
            if (!event.dataTransfer.types.includes("task")) return;
            event.preventDefault();
            
            const draggedTask = document.getElementById("dragged-task");
            const column = event.currentTarget;
            const tasks = column.querySelector(".tasks");
            if (!tasks) return;

            const existingPlaceholder = column.querySelector(".placeholder");
            
            // Optimisation : ne rien faire si on est déjà au bon endroit
            if (existingPlaceholder) {
                const rect = existingPlaceholder.getBoundingClientRect();
                if (event.clientY >= rect.top && event.clientY <= rect.bottom) return;
            }

            const children = Array.from(tasks.children).filter(child => child !== existingPlaceholder && child !== draggedTask);
            let inserted = false;
            for (const task of children) {
                const rect = task.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;
                // Si la souris est au-dessus du milieu de l'élément, on insère avant
                if (event.clientY < midY) {
                    if (existingPlaceholder) existingPlaceholder.remove();
                    tasks.insertBefore(existingPlaceholder ?? makePlaceholder(draggedTask), task);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                if (existingPlaceholder) existingPlaceholder.remove();
                tasks.appendChild(existingPlaceholder ?? makePlaceholder(draggedTask));
            }
        }

        // Initialise le drag & drop des tâches
        function initTaskDragAndDrop() {
            const columns = document.querySelectorAll(".task-column");
            const tasks = document.querySelectorAll(".task");

            tasks.forEach((task) => {
                task.addEventListener("dragstart", (event) => {
                    event.stopPropagation(); // Empêche de drag la colonne en même temps
                    task.id = "dragged-task";
                    event.dataTransfer.effectAllowed = "move";
                    event.dataTransfer.setData("task", "");
                    // Cache visuellement l'élément original
                    setTimeout(() => task.style.display = "none", 0);
                });
                task.addEventListener("dragend", (event) => {
                    task.removeAttribute("id");
                    task.style.display = "block";
                });
            });

            columns.forEach((column) => {
                column.addEventListener("dragover", moveTaskPlaceholder);
                column.addEventListener("dragleave", (event) => {
                    if (column.contains(event.relatedTarget)) return;
                    const placeholder = column.querySelector(".placeholder");
                    if (placeholder) placeholder.remove();
                });
                column.addEventListener("drop", (event) => {
                    if (!event.dataTransfer.types.includes("task")) return;
                    event.preventDefault();
                    event.stopPropagation();
                    
                    const draggedTask = document.getElementById("dragged-task");
                    const placeholder = column.querySelector(".placeholder");
                    
                    draggedTask.style.display = "block";

                    if (placeholder) {
                        placeholder.parentNode.insertBefore(draggedTask, placeholder);
                        placeholder.remove();
                    } else {
                        // Fallback : ajoute à la fin si pas de placeholder
                        column.querySelector(".tasks").appendChild(draggedTask);
                    }
                    updateBoardDataFromDOM();
                });
            });
        }

        // Fonction utilitaire pour trouver où insérer une colonne
        function getDragAfterColumn(container, x) {
            const draggableCols = [...container.querySelectorAll('.task-column:not(.dragging-column)')];
            return draggableCols.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Initialise le drag & drop des colonnes
        function initColumnDragAndDrop() {
            const container = document.querySelector(".container");
            const columns = document.querySelectorAll(".task-column");

            columns.forEach(col => {
                col.addEventListener("dragstart", (event) => {
                    event.dataTransfer.setData("column", col.dataset.id);
                    col.classList.add("dragging-column");
                });
                col.addEventListener("dragend", () => {
                    col.classList.remove("dragging-column");
                });
            });

            container.addEventListener("dragover", (event) => {
                const draggingColumn = document.querySelector(".dragging-column");
                if (!draggingColumn) return; 
                event.preventDefault();
                const afterElement = getDragAfterColumn(container, event.clientX);
                const addListBtn = document.querySelector(".add-column-btn");
                
                // On insère soit avant l'élément trouvé, soit avant le bouton "Ajouter"
                if (afterElement == null) {
                    container.insertBefore(draggingColumn, addListBtn);
                } else {
                    container.insertBefore(draggingColumn, afterElement);
                }
            });

            container.addEventListener("drop", (event) => {
                const draggingColumn = document.querySelector(".dragging-column");
                if (draggingColumn) {
                    event.preventDefault();
                    updateBoardDataFromDOM();
                }
            });
        }

        // Démarrage de l'application
        renderBoard(boardData);
    </script>
</body>
</html>